## tapable 源码分析

### 示例

```
import {SyncHook} from "tapable";
let Car = new SyncHook();
Car.tap('01',(args) => { console.log(args) });
Car.call();
```

##### 分析


* 1，SyncHook是一个类，这个类上有3个自己定义的方法，tapAsync，* tapPromise，compile。
* 2，SyncHook继承了Hook类上的属性和方法，
* 3，Hook类上面绑定了很多的方法，如_createCall，tap等
* 4，Car.tap实际上是调用的Hook上面的tap的方法
* 5，tap方法内部实现

``` js

tap(options, fn) {
		if (typeof options === "string") options = { name: options };
		if (typeof options !== "object" || options === null)
			throw new Error(
				"Invalid arguments to tap(options: Object, fn: function)"
			);
		options = Object.assign({ type: "sync", fn: fn }, options);
		if (typeof options.name !== "string" || options.name === "")
			throw new Error("Missing name for tap");
		options = this._runRegisterInterceptors(options);
		this._insert(options);
	}

```
内部做一些参数处理，同时调用了内部私有函数`_runRegisterInterceptors` 返回一个新的options

```
_runRegisterInterceptors(options) {
		for (const interceptor of this.interceptors) {
			if (interceptor.register) {
				const newOptions = interceptor.register(options);
				if (newOptions !== undefined) options = newOptions;
			}
		}
		return options;
	}
```

然后调用内部函数`_insert`去注册方法，`insert`内部实现

```
_insert(item) {
		this._resetCompilation();
		let before;
		if (typeof item.before === "string") before = new Set([item.before]);
		else if (Array.isArray(item.before)) {
			before = new Set(item.before);
		}
		let stage = 0;
		if (typeof item.stage === "number") stage = item.stage;
		let i = this.taps.length;
		while (i > 0) {
			i--;
			const x = this.taps[i];
			this.taps[i + 1] = x;
			const xStage = x.stage || 0;
			if (before) {
				if (before.has(x.name)) {
					before.delete(x.name);
					continue;
				}
				if (before.size > 0) {
					continue;
				}
			}
			if (xStage > stage) {
				continue;
			}
			i++;
			break;
		}
		this.taps[i] = item;
	}
```

